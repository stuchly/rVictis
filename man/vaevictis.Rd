% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/vaevictis.R
\name{vaevictis}
\alias{vaevictis}
\title{\code{vaevictis}}
\usage{
vaevictis(
  x,
  dim = 2,
  vsplit = 0.1,
  enc_shape = c(128, 128, 128),
  dec_shape = c(128, 128, 128),
  perplexity = 10,
  batch_size = 512L,
  epochs = 100L,
  patience = 0L,
  ivis_pretrain = 0,
  ww = c(10, 10, 1, 1),
  margin = 1,
  shuffle = FALSE,
  load_model = NULL,
  upsample = NULL,
  k = 30
)
}
\arguments{
\item{x}{numeric data matrix.}

\item{dim}{integer (default 2); dimension of reduced data}

\item{vsplit}{double (default 0.1); percentage of data used as validation step in "vaevictis".
By default split is performed before shuffling - see \code{shuffle}}

\item{enc_shape}{integer vector (default \code{c(128,128,128)}); shape (depth and wisth) of the encoder.}

\item{dec_shape}{integer vector (default \code{c(128,128,128)}); shape (depth and wisth) of decoder.}

\item{perplexity}{double (default 10.); perplexity for tsne regularisation see https://www.nature.com/articles/s41467-018-04368-5.}

\item{batch_size}{integer (default 512); batch size for "vaevictis" training.}

\item{epochs}{integer; maximum number of epochs for "vaevictis" training.}

\item{patience}{integer; maxim patience for for "vaevictis" training (early stopping).}

\item{ww}{vector double; weights for vaevictis in this order - tsne regularization, cense regularization, umap regularization, ivis pn loss, reconstruction error, KL divergence}

\item{margin}{double; ivis pn loss margin}

\item{shuffle}{logical; shuffle data before validation split; involves recomputation of KNN matrix}

\item{load_model}{character vector of 2 components; paths to files created by by vae$save(file1,file2) - model is loaded and applied}

\item{upsample}{named list \code{list(labels=,N=,takeall=, cluster=, sampsize=, samples=,method=,pheno_K=,trees=)} or \code{NULL};  sample events by labels;
if NULL nothing happens, \code{N} events per label, \code{labels} vector of labels, takes all events from labels in character vector \code{takeall},
\code{cluster} number of clusters to create vector of labels. If \code{upsample} is not \code{NULL}, \code{N} and unless \code{method}=="phenograph" either \code{labels} or \code{cluster} must be
provided. Clustering is performed if \code{cluster} is not \code{NULL}. \code{samples} and \code{sampsize} are parameters for cluster::clara,
if not provided default values are used.
if \code{method}=="phenograph", parameter \code{pheno_K} (number of NN for phenograph) could be provided (by default \code{pheno_K}==\code{k})}

\item{k}{integer - number of NN for ivis regularisation}

\item{map_only}{logical; return only the mapping not layout}
}
\value{
returns named list list(layout,vae,map) - reduced data, model from python module vaevictis and a pointer to python function to perform the reduction
}
\description{
\code{vaevictis}
}
\details{
see https://github.com/stuchly/vaevictis
}
\examples{
library(rVictis)

res <- vaevictis(iris[,1:4],upsample=list(N=100,cluster=10)) ## 10 clusters by clara, 100 examples from each cluster

plot(res[[1]],col=as.factor(iris[,5])) ## plot reduced data

rediris <- res[[3]](as.matrix(iris[,1:4])) ##apply train reduction on "new" data, now we pass the data to python function - must be matrix

plot(rediris,col=as.factor(iris[,5]))

}
